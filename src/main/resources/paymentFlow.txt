Ah, I see! You want to understand how to process the payment (i.e., capturing the payment) and not just verify it.

Let's break down the full payment flow:

Order Creation: First, we create an order using Razorpay's API. This represents the transaction and generates a unique order_id.

Frontend Payment Form: The user will fill out the payment form on the frontend to pay for the order. Razorpay's checkout will handle this.

Payment Capture: After the user makes a payment, Razorpay will trigger a callback with payment details (including razorpay_payment_id, razorpay_order_id, and razorpay_signature) that need to be verified.

Backend (Verification and Payment Capture): Once the payment details are received on the backend, the signature is verified, and the payment is captured if it's successful.

Full Flow from Backend (Order Creation to Payment Capture)
Step 1: Create the Order (Backend)
The backend first creates an order in Razorpay when the user starts the checkout process.

java
Copy
Edit
package com.booking_app.service;

import com.razorpay.Order;
import com.razorpay.RazorpayClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import java.util.HashMap;
import java.util.Map;

@Service
public class PaymentService {

    @Value("${razorpay.key.id}") // Your Razorpay Key ID
    private String razorpayKeyId;

    @Value("${razorpay.secret.key}") // Your Razorpay Secret Key
    private String razorpaySecretKey;

    private RazorpayClient razorpayClient;

    public PaymentService() throws Exception {
        razorpayClient = new RazorpayClient(razorpayKeyId, razorpaySecretKey);
    }

    /**
     * Create a Razorpay Order.
     * @param amount - The amount to charge (in paise, e.g. ₹500 = 50000)
     * @param currency - The currency (usually "INR")
     * @return - The Razorpay Order ID
     */
    public String createOrder(int amount, String currency) throws Exception {
        // Parameters for the order
        Map<String, Object> orderRequest = new HashMap<>();
        orderRequest.put("amount", amount); // Amount in paise
        orderRequest.put("currency", currency);
        orderRequest.put("payment_capture", 1); // 1 means automatic payment capture

        // Create the order
        Order order = razorpayClient.orders.create(orderRequest);

        // Return the order ID
        return order.get("id");
    }
}
Step 2: Frontend Payment Flow
The frontend uses Razorpay's checkout form to let the user complete the payment.

javascript
Copy
Edit
// React - Open Razorpay Checkout

const openCheckout = (orderId, amount) => {
    var options = {
        key: "YOUR_KEY_ID", // Replace with your Razorpay key ID
        amount: amount,     // Amount to charge (in paise, e.g. ₹500 = 50000)
        currency: "INR",
        order_id: orderId,  // Order ID generated from backend
        handler: function (response) {
            // Send response to backend for verification
            const { razorpay_payment_id, razorpay_order_id, razorpay_signature } = response;
            verifyPayment(razorpay_payment_id, razorpay_order_id, razorpay_signature);
        },
        prefill: {
            name: "Customer Name",
            email: "customer@example.com",
            contact: "1234567890"
        }
    };
    
    var rzp1 = new Razorpay(options);
    rzp1.open();
};

// Verify Payment after Razorpay Checkout
const verifyPayment = (razorpayPaymentId, razorpayOrderId, razorpaySignature) => {
    fetch("http://localhost:8080/payment/verify", {
        method: "POST",
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
            razorpay_payment_id: razorpayPaymentId,
            razorpay_order_id: razorpayOrderId,
            razorpay_signature: razorpaySignature,
        }),
    })
    .then((response) => response.text())
    .then((data) => console.log(data))
    .catch((error) => console.error("Error verifying payment:", error));
};
Step 3: Backend (Payment Verification and Capture)
Once the user completes the payment, Razorpay sends the payment details (razorpay_payment_id, razorpay_order_id, and razorpay_signature) to the backend for verification.

This is where we verify the payment signature and capture the payment if everything is valid.

java
Copy
Edit
package com.booking_app.controller;

import com.booking_app.service.PaymentService;
import com.booking_app.util.RazorpaySignatureUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/payment")
public class PaymentController {

    @Autowired
    private PaymentService paymentService;

    @PostMapping("/verify")
    public String verifyPayment(@RequestParam Map<String, String> paymentDetails) {
        try {
            // Extract payment details from Razorpay callback (Payment ID, Order ID, Signature)
            String razorpayOrderId = paymentDetails.get("razorpay_order_id");
            String razorpayPaymentId = paymentDetails.get("razorpay_payment_id");
            String razorpaySignature = paymentDetails.get("razorpay_signature");

            // Verify the signature
            boolean isSignatureValid = RazorpaySignatureUtil.verifySignature(
                    razorpayOrderId, razorpayPaymentId, razorpaySignature, paymentService.getRazorpaySecretKey()
            );

            if (isSignatureValid) {
                // Process the payment (Capture)
                // This is just a simulation. You would typically update the order status in your DB
                paymentService.updatePaymentStatus(razorpayOrderId, "paid");
                return "Payment Verified Successfully!";
            } else {
                // If verification failed, mark the order as failed
                paymentService.updatePaymentStatus(razorpayOrderId, "failed");
                return "Payment Verification Failed!";
            }
        } catch (Exception e) {
            return "Error during payment verification: " + e.getMessage();
        }
    }
}
Step 4: Payment Capture
Razorpay automatically captures the payment if payment_capture = 1 is set when creating the order. However, if you want to manually capture a payment (for example, for delayed payment capture), you can do so after the signature is verified.

For instance, if you have to manually capture the payment:

java
Copy
Edit
package com.booking_app.service;

import com.razorpay.Payment;
import com.razorpay.RazorpayClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class PaymentService {

    @Value("${razorpay.key.id}")
    private String razorpayKeyId;

    @Value("${razorpay.secret.key}")
    private String razorpaySecretKey;

    private RazorpayClient razorpayClient;

    public PaymentService() throws Exception {
        razorpayClient = new RazorpayClient(razorpayKeyId, razorpaySecretKey);
    }

    // This method is only required if you want to manually capture a payment
    public Payment capturePayment(String paymentId, int amount) throws Exception {
        Payment payment = razorpayClient.payments.fetch(paymentId);
        return payment.capture(amount);
    }

    public String getRazorpaySecretKey() {
        return razorpaySecretKey;
    }

    public void updatePaymentStatus(String orderId, String status) {
        // Update the payment status in your database
        System.out.println("Updating order " + orderId + " to " + status);
    }
}
Flow Summary (Full Process)
Backend (Order Creation):

Create the Razorpay order using Razorpay's API (payment_capture = 1 automatically captures the payment).

Return the order_id to the frontend.

Frontend (Payment Form):

Razorpay Checkout handles payment submission and sends the razorpay_payment_id, razorpay_order_id, and razorpay_signature to the backend.

Backend (Payment Verification and Capture):

Verify the signature using the secret key.

If the signature is valid, update the order status and mark the payment as "paid".

If the signature is invalid, mark the order status as "failed".

Optional (Manual Capture):

If you want to manually capture payments (instead of using payment_capture = 1), you can call the capturePayment method in the backend after signature verification.

Conclusion:
Order Creation: Done via Razorpay's orders.create() API.

Frontend: Handles payment submission via Razorpay Checkout.

Backend: Verifies the payment and captures it (if not already done automatically).

Capture: Razorpay's automatic payment capture happens if payment_capture = 1, but you can also manually capture the payment via the backend if needed.

